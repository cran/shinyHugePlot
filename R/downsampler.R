#' R6 class for down-sampling data
#'
#' @export
#' @docType class
#' @format An \code{R6::R6Class} object
#' @importFrom R6 R6Class
#' @importFrom assertthat assert_that
#' @importFrom data.table as.data.table setkey
#' @importFrom dplyr %>% case_when filter if_else bind_rows select left_join
#' @importFrom stringr str_replace str_sub str_subset
#' @importFrom stringr str_extract str_remove str_detect
#' @importFrom purrr map map_chr map_dfr compact pmap
#' @importFrom tibble tibble as_tibble
#' @importFrom bit64 as.integer64
#' @importFrom nanotime as.nanotime
#' @importFrom plotly add_trace subplot
#' @importFrom tidyr unnest pivot_wider
#' @importFrom lazyeval f_eval
#' @description
#' A class for down-sampling the data.
#' See the super class (\code{plotly_datahandler}) to find more members.
#' Two options to make a \code{shiny} app: use \code{shiny_hugeplot} and
#' make it by yourself.
#' See the example.
#' @examples
#' \donttest{
#' data(noise_fluct)
#'
#' # example 1: where shiny_hugeplot is employed
#' # It is very easy
#' # but customize is difficult and the computation cost might be high
#' shiny_hugeplot(noise_fluct$t, noise_fluct$level)
#'
#' # example 2: where user-defined shiny app is employed
#' # a little complex
#' # but any layout can be defined and the user can select the method
#' # where the computation cost is lowest.
#'
#' fig <- plot_ly(
#'   x = noise_fluct$t,
#'   y = noise_fluct$level,
#'   type = "scatter",
#'   mode = "lines"
#'   ) %>%
#'   layout(xaxis = list(type = "date")) %>%
#'   shinyHugePlot::plotly_build_light()
#'
#' ds <- downsampler$new(figure = fig)
#'
#' ui <- fluidPage(
#'   plotlyOutput(outputId = "hp", width = "800px", height = "600px")
#' )
#'
#' server <- function(input, output, session) {
#'
#'   output$hp <- renderPlotly(ds$figure)
#'
#'   observeEvent(plotly::event_data("plotly_relayout"),{
#'     updatePlotlyH(session, "hp", plotly::event_data("plotly_relayout"), ds)
#'   })
#'
#' }
#'
#' shinyApp(ui = ui, server = server)
#'
#' }

# class decralation -------------------------------------------------------

downsampler <- R6::R6Class(
  "downsampler",
  inherit = plotly_datahandler,

# public members ----------------------------------------------------------
  public = list(
    # constructor ---------------------------------------------------------
    #' @description
    #' Constructing an abstract down-sampler.
    #' @param figure,legend_options,tz
    #' Arguments passed to \code{plotly_datahandler$new}.
    #' @param n_out Integer or numeric.
    #' The number of samples shown after down-sampling. By default 1000.
    #' @param aggregator An instance of an R6 class for aggregation.
    #' Select an aggregation function. The list of the functions are obtained
    #' using \code{list_aggregators}.
    #' By default, \code{min_max_aggregator$new()}.
    #'
    initialize = function(
      figure = plotly::plot_ly(),
      n_out = 1000L,
      aggregator = min_max_aggregator$new(),
      tz = Sys.timezone(),
      legend_options = list(
        name_prefix  = '<b style="color:sandybrown">[R]</b> ',
        name_suffix  = "",
        xdiff_prefix = '<i style="color:#fc9944"> ~',
        xdiff_suffix = "</i>"
      )
    ) {

      # register the data
      super$initialize(
        figure = figure,
        legend_options = legend_options,
        tz = tz
      )

      # check classes and lengths of the arguments
      assertthat::assert_that(inherits(n_out, c("numeric", "integer")))
      assertthat::assert_that(inherits(aggregator, "aggregator"))

      # register the values other than figure
      private$n_out_def      <- n_out[1]
      private$aggregator_def <- aggregator

      # register downsample options
      self$set_downsample_options()
      # set the initial data
      self$update_trace(reset = TRUE)

      invisible()

    }, #end of initialization



    #' @description
    #' Update traces (\code{self$figure$x$data}) according to
    #' the relayout order (\code{relayout_order}).
    #' @param relayout_order Named list.
    #' The list generated by \code{plotlyjs_relayout},
    #' which is obtained using \code{plotly::event_data}.
    #' e.g.,
    #' If you would like set the range of the 2nd x axis to [10.0, 21.5],
    #' \code{list(xaxis2.range[0] = 10.0, xaxis2.range[1] = 21.5)}.
    #' If you would like reset the range of the 1st x axis,
    #' \code{list(xaxis.autorange = TRUE, xaxis.showspike = TRUE)}.
    #' @param reset Boolean.
    #' If it is \code{TRUE}, all other arguments are neglected and
    #' the figure will be reset (all the ranges of x axes are initialized).
    #' By default, \code{FALSE}.
    #' @param reload Boolean.
    #' If it is \code{TRUE}, the ranges of the figure are preserved but
    #' the aggregation will be conducted with the current settings.
    #' By default, \code{FALSE}.
    #' @param send_trace Boolean.
    #' If it is \code{TRUE}, a named list will be returned,
    #' which contains the indexes of the traces that will be updated
    #' (\code{trace_idx_update}) and the updated traces (\code{new_trace}).
    #' By default, \code{FALSE}.
    update_trace = function(
        relayout_order = list(NULL),
        reset = FALSE, reload = FALSE, send_trace = FALSE
    ) {

      # check arguments
      if (is.null(relayout_order)) return()
      assertthat::assert_that(inherits(relayout_order, "list"))
      assertthat::assert_that(inherits(reset, "logical"))
      assertthat::assert_that(inherits(reload, "logical"))
      assertthat::assert_that(inherits(send_trace, "logical"))

      # stop if the order is NULL and no reset or reload
      if (is.null(relayout_order[[1]]) && !reset && !reload) return()

      # if there are no x-axis order and no reset or reload, stop here
      if (
        !any(stringr::str_detect(names(relayout_order), "^xaxis")) &&
        !reset && !reload
        ) {
        return()
      }

      # compute relayout_order_df
      relayout_order_df <- private$relayout_order_to_df(
        relayout_order = relayout_order,
        reset = reset, reload = reload
        )

      # if the relayout_order_df is null, stop here
      if (is.null(relayout_order_df) || nrow(relayout_order_df) == 0) return()


      # compute updated data of the traces
      traces_update_df <- private$construct_agg_traces(relayout_order_df)
      # detect the index of the trace to be updated
      if (is.null(self$figure$x$data) ||
          any(purrr::map_lgl(self$figure$x$data, ~is.null(.$uid)))
      ) {
        trace_idx_update <- integer()
        self$figure$x$data <- NULL
      } else {
        trace_idx_update <- purrr::map(
          unique(traces_update_df$uid),
          ~which(.x == purrr::map_chr(self$figure$x$data, ~.x$uid))
        ) %>%
          unlist()

        # delete the traces to be updated
        self$figure$x$data <- self$figure$x$data[-trace_idx_update]
      }

      new_trace <- traces_update_df$trace %>%
        purrr::keep(~"x" %in% names(.x))

      # register the new data
      self$figure$x$data <- c(
        self$figure$x$data,
        new_trace
      )

      if (send_trace) {
        return(
          list(trace_idx_update = trace_idx_update,
               new_trace = new_trace
              )
        )

      } else {
        invisible()
      }
    },

    #' @description
    #' Set the options for aggregating the traces.
    #' @param uid Character, optional.
    #' The unique id of the trace.
    #' If \code{NULL}, all the ids registered in this instance is used.
    #' By default, \code{NULL}.
    #' @param n_out Numeric or integer, optional.
    #' The number of samples output by the aggregator.
    #' If \code{NULL}, the default value registered in this instance is used.
    #' By default, \code{NULL}.
    #' @param aggregator \code{aggregator} object, optional.
    #' An instance that aggregate the data.
    #' If \code{NULL}, the default value registered in this instance is used.
    set_downsample_options = function(
      uid = NULL, n_out = NULL, aggregator = NULL
    ){
      if (is.null(uid)) uid <- private$traces_df$uid
      if (is.null(n_out)) n_out <- private$n_out_def
      if (is.null(aggregator)) aggregator <- private$aggregator_def
      assertthat::assert_that(inherits(uid, "character"))
      assertthat::assert_that(inherits(n_out, c("numeric", "integer")))
      assertthat::assert_that(inherits(aggregator, "aggregator"))

      private$ds_options <- dplyr::bind_rows(
        private$ds_options[private$ds_options[["uid"]] != uid, ],
        tibble(
          uid = uid,
          aggregator_inst = list(aggregator),
          aggregator_name = class(aggregator)[1],
          n_out = n_out,
          interleave_gaps = aggregator$interleave_gaps,
          nan_position = aggregator$nan_position
        )
      )
      invisible()
    }
  ), # end of the public member

  active = list(
    #' @field downsample_options Options for down-sampling the data
    #' set in this instance.
    downsample_options = function() private$ds_options,
    #' @field n_out_default Default sample size set in this instance.
    n_out_default = function() private$n_out_def,
    #' @field aggregator_default Default aggregator set in this instance.
    aggregator_default = function() private$aggregator_def

  ),


# private members ---------------------------------------------------------

  private = list(

    # downsample options such as aggregator and n_out
    ds_options = NULL,
    # the number of samples shown after down-sampling
    n_out_def = 0L,
    # the dafault aggregator
    aggregator_def = NULL,


    # change the relayout_order to data frame that contains uid and range
    relayout_order_to_df = function(
      relayout_order, reset = FALSE, reload = FALSE
      ) {

      assertthat::assert_that(inherits(relayout_order, "list"))

      # show the relayout order
      message(paste(
        paste(
          "relayout order: {",
          paste(
            paste(names(relayout_order), relayout_order, sep = ":"),
            collapse = " "
          ),
          "}"
        )
      ))

      # prepare blank data frame for the type of the relayout order
      order_type_blank <- tibble::tribble(
        ~`range[0]`, ~`range[1]`, ~autorange, ~showspikes,
        list(NULL),  list(NULL),  NA,         NA
      ) %>% .[0,]

      ###
      # First, convert the order to data frame
      # The necessary data is xaxis, start and end values
      ###

      # if the update is resetd, all the xaxis is reset
      if (reset) {
        x_order_df <- tibble(
          xaxis = purrr::map_chr(
            self$figure$x$data,
            ~stringr::str_replace(.x$xaxis, "^x", "xaxis")
          ),
          start = list(NA),
          end = list(NA)
        ) %>%
          dplyr::distinct(xaxis, .keep_all = TRUE)

      # else if the update is caused by the change of the aggregation method,
      # keep ranges but update values
      } else if (reload) {
        x_order_df <- self$plotly_data_to_df(
          self$figure$x$data, use_datatable = FALSE
          ) %>%
          dplyr::mutate(
            xaxis = stringr::str_replace(xaxis, "^x", "xaxis"),
            start = purrr::map(x, ~min(.x, na.rm = TRUE)),
            end   = purrr::map(x, ~max(.x, na.rm = TRUE))
          ) %>%
          tidyr::nest(data = -xaxis) %>%
          dplyr::mutate(
            data = purrr::map(
              data,
              ~tidyr::unnest(.x, c(start, end)) %>%
                dplyr::summarise(
                  start = list(min(start, na.rm = TRUE)),
                  end = list(max(end, na.rm = TRUE))
                )
            )
          ) %>%
          tidyr::unnest(data)

      # else, update according to the order
      } else {
        x_order_df <- as_tibble(relayout_order) %>%
          dplyr::mutate(across(.fns = list)) %>%
          tidyr::pivot_longer(
            everything(),
            names_sep = "\\.", names_to = c("xaxis", "type")
          ) %>%
          dplyr::filter(stringr::str_detect(xaxis, "^xaxis")) %>%
          tidyr::pivot_wider(names_from = type, values_from = value) %>%
          tidyr::unnest(matches("autorange|showspikes")) %>%
          bind_rows(
            order_type_blank[setdiff(colnames(order_type_blank), colnames(.))]
          ) %>%
          dplyr::filter(
            (!purrr::map_lgl(`range[0]`, is.null) &
               !purrr::map_lgl(`range[0]`, is.null)) |
              (!is.na(autorange) & !is.na(showspikes))
          ) %>%
          dplyr::select(xaxis, start = `range[0]`, end = `range[1]`) %>%
          dplyr::mutate(
            across(
              c(start, end),
              ~dplyr::if_else(
                purrr::map_lgl(.x, is.null),
                list(NA),
                .x
              )
            )
          )
      }

      # return NULL if the data frame is virtually NULL
      if (nrow(x_order_df) == 0) return()

      ###
      # Then, link the order to the trace uid
      ###
      relayout_order_df <- private$traces_df %>%
        dplyr::select(uid, xaxis) %>%
        dplyr::inner_join(
          x_order_df %>%
            dplyr::mutate(xaxis = stringr::str_replace(xaxis, "^xaxis", "x")),
          by = "xaxis"
        ) %>%
        dplyr::mutate(
          across(
            c(start, end),
            ~modify_if(
              .x, ~inherits(.x, c("POSIXt", "character")),
              ~private$plotlytime_to_nanotime(.x, private$tz)
            )
          )
        )

      return(relayout_order_df)
    },

    # construct a data frame of aggregated traces,
    # by employing the data frame representing relayout_order.
    construct_agg_traces = function(relayout_order_df = NULL) {

      # check arguments
      if (is.null(relayout_order_df)) return()
      assertthat::assert_that(inherits(relayout_order_df, "data.frame"))
      assertthat::assert_that(
        length(
          setdiff(c("uid", "start", "end"), colnames(relayout_order_df))
          ) == 0,
        msg = "uid, start and end columns must be included in the data frame"
      )

      # select columns
      traces_update_df <- relayout_order_df[c("uid", "start", "end")]

      # MAIN aggregation
      traces_update_df$agg_result <- purrr::pmap(
        traces_update_df %>%
          dplyr::left_join(private$traces_df, by = "uid") %>%
          dplyr::left_join(private$ds_options, by = "uid") %>%
          dplyr::rename(aggregator = aggregator_inst)
        ,
        private$aggregate_trace,
      )

      # construct a list representing a trace
      traces_update_list <- traces_update_df %>%
        tidyr::unnest(agg_result) %>%
        dplyr::select(-start, -end) %>%
        dplyr::mutate(
          data = purrr::modify_if(
            data,
            ~inherits(.x, "data.frame"),
            ~dplyr::summarise(.x, across(.fns = list))
            ) %>%
            purrr::modify_if(
              ~inherits(.x, "list"),
              ~purrr::modify_if(.x, ~length(.x) > 1, list) %>% as_tibble(.x)
            )
        ) %>%
        tidyr::unnest(data) %>%
        dplyr::left_join(
          private$traces_df[c(
            "uid",
            setdiff(colnames(private$traces_df), c(colnames(.), "data"))
          )],
          by = "uid"
        ) %>%
        as.list() %>%
        purrr::transpose() %>%
        purrr::map(~purrr::discard(.x, ~all(is.na(.x))))

      # return a data frame including the traces and its uids.
      return(
        tibble(
          uid = purrr::map_chr(traces_update_list, ~.x$uid),
          trace = traces_update_list
        )
      )
    },

    # MAIN aggregation process
    # it returns the aggregated trace and the name in data frame
    aggregate_trace = function(
      data, start, end, name, legendgroup, aggregator, n_out, ...
      ) {

      # extract data
      if (!is.na(start) && length(start) > 0 &&
          !is.na(end)   && length(end)   > 0) {
        data <- data[x >= start & x <= end]
      } else {
        data <- data
      }

      # number of the extracted data
      nrow_orig <- nrow(data)
      # down-sample x and y
      data_agg <- aggregator$
        aggregate(
          data$x, data$y, n_out
        )%>%
        data.table::as.data.table() %>%
        merge(
          data[,
               intersect(colnames(data), c("x", "text", "hovertext")),
               with = FALSE],
          all.x = TRUE, sort = FALSE
          )


      # number of the aggregated data
      nrow_agg <- nrow(data_agg)


      # generate a message about the down-sampling
      msg <- paste0(
        name,
        if_else(is.na(legendgroup), "", paste0("/", legendgroup)),
        ": ",
        if_else(
          nrow_orig == nrow_agg,
          paste0("no down-sample (n: ", nrow_orig, ")"),
          paste0("applied down-sample (n: ", nrow_orig, " -> ", nrow_agg, ")")
        )
      )
      message(msg)

      # if no data, stop here
      if (nrow_agg == 0) {
        return(tibble(name = as.character(name), data = list(data_agg)))
      }

      # generate a name for aggregation
      name <- if_else(
        nrow_orig == nrow_agg,
        as.character(name),
        private$cmpt_trace_name(name, data_agg$x)
      )

      # format x values if the x is nanotime
      if (inherits(data_agg$x, "nanotime")) {
        data_agg$x <- private$nanotime_to_plotlytime(data_agg$x, private$tz)
      }

      # add the range of the data if the aggregator is rng_aggregator
      if (inherits(aggregator, "rng_aggregator")) {
        data_rng <- aggregator$as_plotly_range(
          x = data_agg$x, y = data_agg$y,
          ylwr = data_agg$ylwr, yupr = data_agg$yupr
          )

        data_agg <- data_agg[, c("x", "y"), with = FALSE]
        data_agg <- c(list(data_agg), list(data_rng))
      } else {
        data_agg <- list(data_agg)
      }

      # finally constitute the result tibble
      agg_result <- tibble(
        name = name,
        data = data_agg
      )

      return(agg_result)
    }
  ) # end of the private member
) # end of the R6 class
