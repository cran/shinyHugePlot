#' Wrapper for updating plotly with large-sized data
#'
#' @description
#' using this function, figure updater is registered in shiny app.
#' The figure updater receives events in plotly and update the figure.
#' @param session The \code{session} object passed to function given to
#' \code{shinyServer}.
#' @param outputId Character. The outputId of the plotly that will be
#' down-sampled
#' @param relayout_order Named list.
#' The list generated by \code{plotlyjs_relayout},
#' which is obtained using \code{plotly::event_data}.
#' @param ds_obj \code{downsampler} instance
#' that contains the original data and used for generating the figure.
#' @param reset Boolean.
#' It it is \code{TRUE}, the figure will be updated even if
#' \code{relayout_order} is \code{NULL}.
#' The ranges of x axes are reset (initialized).
#' @param reload Boolean.
#' It it is \code{TRUE}, the figure will be updated even if
#' \code{relayout_order} is \code{NULL}.
#' The ranges of x axes are preserved.
#' @export
#' @examples
#'\donttest{
#' data(noise_fluct)
#' fig <- plot_ly(x = d$x, y = d$y, type = "scatter", mode = "lines")
#'
#' ds <- downsampler$new(figure = fig)
#'
#' ui <- fluidPage(
#'   plotlyOutput(outputId = "hp", width = "800px", height = "600px")
#' )
#'
#' server <- function(input, output, session) {
#'
#'   output$hp <- renderPlotly(ds$figure)
#'
#'   observeEvent(plotly::event_data("plotly_relayout"),{
#'     updatePlotlyH(session, "hp", plotly::event_data("plotly_relayout"), ds)
#'   })
#'
#' }
#'
#' shinyApp(ui = ui, server = server)
#'}
updatePlotlyH <- function(
    session, outputId, relayout_order, ds_obj,
    reset = FALSE, reload = FALSE
    ) {

  assertthat::assert_that(inherits(ds_obj, "downsampler"))

  trace_update_order <- ds_obj$update_trace(
    relayout_order = relayout_order,
    reset = reset, reload = reload, send_trace = TRUE
    )

  if (!is.null(trace_update_order) && length(trace_update_order$new_trace) > 0) {
    plotlyProxy(outputId, session) %>%
      plotlyProxyInvoke(
        "deleteTraces", unique(trace_update_order$trace_idx_update) - 1
      ) %>%
      plotlyProxyInvoke(
        "addTraces",
        trace_update_order$new_trace
      )
  }
}
